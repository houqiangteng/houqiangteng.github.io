<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Log Binning绘图拟合参数</title>
    <url>/2022/04/05/%E5%88%A9%E7%94%A8Log%20Binning%E7%BB%98%E5%9B%BE%E6%8B%9F%E5%90%88%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>绘制度分布是分析网络属性的一个组成部分。该过程从获得<span
class="math inline">\(N_{k}\)</span>开始，即度数为<span
class="math inline">\(k\)</span>的节点数。这可以通过直接测量或模型来提供。从<span
class="math inline">\(N_{k}\)</span>我们计算出<span
class="math inline">\(p_{k}=N_{k}/N\)</span>。问题是，如何绘制<span
class="math inline">\(p_{k}\)</span>以最好地提取其属性。<span id="more"></span></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/50e5884aa2254dae982de3f875aee4b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVuZ0FkdmVudHVyZQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"
alt="图 度分布在不同标度坐标下的表示" />
<figcaption aria-hidden="true">图
度分布在不同标度坐标下的表示</figcaption>
</figure>
<ul>
<li>使用log-log图</li>
</ul>
<p>在无标度网络中，具有一或两条链路的众多节点与少数节点共存，其中少数节点为具有数千甚至数百万链路的节点。使用线性
k 轴压缩无数小k区域中的节点，使它们不可见。类似地，由于<span
class="math inline">\(k=1\)</span>和大<span
class="math inline">\(k\)</span>的<span
class="math inline">\(p_{k}\)</span>可能存在数量级差异，如果我们在线性垂直轴上绘制<span
class="math inline">\(p_{k}\)</span>，大<span
class="math inline">\(k\)</span>的值将显示为零（图
4.22a）。对数图的使用避免了这些问题。 我们可以使用10次方的对数轴（图
4.22b），或者我们可以绘制<span class="math inline">\(\log
k\)</span>函数的<span class="math inline">\(\log
k\)</span>。请注意，<span class="math inline">\(p_{k}=0\)</span>或<span
class="math inline">\(k=0\)</span>的点不会在<span
class="math inline">\(\log - \log\)</span>图上显示，因为<span
class="math inline">\(\log0=-\infty\)</span>。</p>
<ul>
<li>避免Linear Binning</li>
</ul>
<p>最有缺陷的方法（但在文献中经常出现）是在对数图上简单地绘制<span
class="math inline">\(p_{k}=N_{k}/N\)</span>（图
4.22b）。这称为线性分箱（Linear
Binning），因为每个bin具有相同的大小<span class="math inline">\(\Delta
k=1\)</span>。对于无标度网络，linear binning会在大<span
class="math inline">\(k\)</span>处产生显而易见的平台，由形成水平线的大量数据点组成（图
4.22b）。这个平台有一个简单的解释：通常我们只有一个高度节点的样本，因此在高
<span class="math inline">\(k\)</span>区域中，我们要么有<span
class="math inline">\(N_{k}=0\)</span>（没有具有<span
class="math inline">\(k\)</span>度的节点），要么有<span
class="math inline">\(N_{k}=1\)</span>（具有<span
class="math inline">\(k\)</span>度的单个节点）。 因此，Linear
Binning将提供<span
class="math inline">\(p_{k}=0\)</span>（未在对数图上显示）或<span
class="math inline">\(p_{k}=1/N\)</span>（适用于所有hubs），在<span
class="math inline">\(p_{k}=1/N\)</span>处生成一个平台。
这个平台会影响我们估计度指数<span
class="math inline">\(\gamma\)</span>的能力。例如，如果我们尝试使用linear
binning对图4.22b中所示的数据拟合幂律，则获得的<span
class="math inline">\(\gamma\)</span>与实际值<span
class="math inline">\(\gamma =2.5\)</span>完全不同。原因是在linear
binning下，我们在小<span
class="math inline">\(k\)</span>的bin中有大量节点，这使我们能够自信地在这种情况下拟合<span
class="math inline">\(p_{k}\)</span>。在大<span
class="math inline">\(k\)</span>的bin中，我们的节点太少，无法对<span
class="math inline">\(p_{k}\)</span>进行适当的统计估计。相反，新出现的平台会使得拟合参数偏离。然而，正是这种高<span
class="math inline">\(k\)</span>状态在确定<span
class="math inline">\(\gamma\)</span>中起关键作用。增加bin大小不会解决这个问题。因此，建议避免对肥尾分布进行Linear
binning。</p>
<ul>
<li>使用Logarithmic Binning</li>
</ul>
<p>​Logarithmic binning纠正了linear
binning的非均匀采样。对于log-binning，我们让bin大小随程度增加，确保每个bin具有相当数量的节点。例如，我们可以选择bin大小为2的倍数，这样第一个bin的大小为<span
class="math inline">\(b_{0}=1\)</span>，包含所有<span
class="math inline">\(k=1\)</span>的节点；第二个大小为<span
class="math inline">\(b_{1}=2\)</span>，包含度数<span
class="math inline">\(k=2,3\)</span>的节点；第三个bin的大小为<span
class="math inline">\(b_{2}=4\)</span>，包含度数<span
class="math inline">\(k=4,5,6,7\)</span>的节点。通过归纳，第<span
class="math inline">\(n\)</span>个bin的大小为<span
class="math inline">\(2^{n-1}\)</span>，包含度数为<span
class="math inline">\(k=2^{n-1},2^{n-1}+1,...,2^{n}-1\)</span>的节点。请注意，bin大小可以随任意增量增加，<span
class="math inline">\(b_{n}=c^{n}\)</span>，其中<span
class="math inline">\(c&gt;1\)</span>。度分布由<span
class="math inline">\(p_{\left \langle k \right
\rangle}=N_{n}/\left(Nb_{n} \right)\)</span>给出，其中<span
class="math inline">\(N_{n}\)</span>是在大小为<span
class="math inline">\(b_{n}\)</span>的<span
class="math inline">\(bin_{n}\)</span>中找到的节点数，<span
class="math inline">\(\left \langle k_{n} \right
\rangle\)</span>是bin<span
class="math inline">\(b_{n}\)</span>中节点的平均度数。
图4.22c显示了logarithmic binning的<span
class="math inline">\(p_{k}\)</span>。请注意，现在扩展到高<span
class="math inline">\(k\)</span>平台，其本来在linear
binning下不可见。因此，logarithmic
binning也可以从稀有的高度节点中提取有用信息。由于上述操作相当于把每个bin中的度的<span
class="math inline">\(p_{k}\)</span>进行平均，所以最终在高<span
class="math inline">\(k\)</span>的bin中有些<span
class="math inline">\(p_{k}\)</span>是0，所以平均之后的值要小于<span
class="math inline">\(p_{k}=1/N\)</span>，这是要值得注意的。</p>
<ul>
<li>使用累积分布（Cumulative Distribution）</li>
</ul>
<p>​从<span
class="math inline">\(p_{k}\)</span>的尾部提取信息的另一种方法是绘制互补累积分布，
<span class="math display">\[
\begin{equation}
P_{k}=\sum^{\infty}_{q=k+1}p_{q},
\end{equation}
\]</span> 这再次增强了高k区域的统计显著性。 如果<span
class="math inline">\(p_{k}\)</span>遵循幂律<span
class="math inline">\(p_{k}=k^{-\gamma}\)</span>，则累积分布缩放为 <span
class="math display">\[
\begin{equation}
p_{k}\sim k^{-\gamma+1}.
\end{equation}
\]</span> 累积分布再次消除了linear binning观察到的平台,并扩展了区域（图
4.22d），从而可以更准确地估计度指数。</p>
<ul>
<li>注意</li>
</ul>
<ol type="1">
<li>当横坐标并非为离散的变量时，需要先把连续变量粗粒化，然后利用每个格子代替k值进行上述操作；</li>
<li>但是Logarithmic
Binning中，横坐标取的是线性区间的中间值，而画图时为对数区间，所以这个上面可能需要有所商量，即有可能取对数区间最优；</li>
<li>特别值得注意的是，当我们把上述log-binning之后的区间画在<span
class="math inline">\(\log\)</span>图中的时候，其点的横坐标并非是等间隔均匀分布的，当格子的下标比较大的时候，横坐标才会逼近等间隔分布。用度分布的例子，证明如下：
log-binning的格子为： <span class="math display">\[
\begin{equation}
k=1,k=2,3,k=4,5,6,7,...,k=2^{n-1},2^{n-1}+1,...,2^{n}-1
\end{equation}
\]</span> 平均度<span class="math inline">\(\left \langle k_{n} \right
\rangle\)</span>的分布为： <span class="math display">\[
\begin{equation}
\begin{aligned}
\left \langle k_{n} \right \rangle&amp;=\frac{S_{n-1}+1+S_{n}}{2}\\
&amp;=\frac{2^{n-1}-1+1+2^{n}-1}{2}\\
&amp;=3\times2^{n-2}-\frac{1}{2}
\end{aligned}
\end{equation}
\]</span> 当<span
class="math inline">\(n\rightarrow\infty\)</span>时，<span
class="math inline">\(\left\langle k_{n} \right\rangle\)</span>在<span
class="math inline">\(\log\)</span>坐标下的值为： <span
class="math display">\[
\begin{equation}
\begin{aligned}
\left\langle k_{n} \right\rangle_{log}&amp;=\log\left( \left\langle
k_{n} \right\rangle \right) \\
&amp;=\log\left( 3\times2^{n-2}-\frac{1}{2} \right)\\
&amp;\approx \log\left( 3\times2^{n-2} \right)\\
&amp;\approx (n-2)\log\left( 2 \right)+ \log\left( 3\right)\\
&amp;\approx n\log\left( 2 \right)+ \log\left( \frac{3}{4}\right)\\
&amp;\approx n\log\left( 2 \right)
\end{aligned}
\end{equation}
\]</span></li>
</ol>
<p>即在<span class="math inline">\(\log\)</span>坐标下，<span
class="math inline">\(\left\langle k_{n}
\right\rangle\)</span>的间距为<span
class="math inline">\(\log(2)\)</span>。
另外观察上述推导过程，最终的间距只与选择的比值<span
class="math inline">\(q\)</span>有关，即间距为<span
class="math inline">\(\log(q)\)</span>。下面对一般情况下的离散变量进行证明，假设初值<span
class="math inline">\(b_{1}=a_{1}\)</span>，比值<span
class="math inline">\(q&gt;1\)</span>，则前<span
class="math inline">\(n\)</span>项的求和为： <span
class="math display">\[
\begin{equation}
S_{n}=\frac{a_{1}(1-q^{n})}{1-q}
\end{equation}
\]</span> 平均度<span class="math inline">\(\left \langle k_{n} \right
\rangle\)</span>的分布为： <span class="math display">\[
\begin{equation}
\begin{aligned}
\left \langle k_{n} \right \rangle&amp;=\frac{S_{n-1}+1+S_{n}}{2}\\
&amp;=\frac{(1+q)a_{1}q^{n-1}}{2(q-1)}+\frac{a_{1}}{1-q}+\frac{1}{2}\\
&amp;\approx \frac{(1+q)a_{1}q^{n-1}}{2(q-1)}
\end{aligned}
\end{equation}
\]</span></p>
<p>当<span class="math inline">\(n\rightarrow\infty\)</span>时，<span
class="math inline">\(\left\langle k_{n} \right\rangle\)</span>在<span
class="math inline">\(\log\)</span>坐标下的值为： <span
class="math display">\[
\begin{equation}
\begin{aligned}
\left\langle k_{n} \right\rangle_{log}&amp;=\log\left( \left\langle
k_{n} \right\rangle \right)\\
&amp;=\log\left(\frac{(1+q)a_{1}q^{n-1}}{2(q-1)} \right)\\
&amp;=\log(\frac{(q+1)a_{1}}{2(q-1)q})+n\log(q)\\
&amp;\approx n\log(q)
\end{aligned}
\end{equation}
\]</span> 证毕。</p>
<ul>
<li>附录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%计算log-binning</span><br><span class="line">function [edges_exponent,N_hist_exponent]=LogBinning(N_hist,edges,first_bin,exponent_base)</span><br><span class="line">%N_hist为数据，edges为横坐标（其length比N_hist多1），first_bin为横坐标第一个格子大小；</span><br><span class="line">%exponent_base为比值；</span><br><span class="line">%edges_exponent为横坐标，N_hist_exponent为纵坐标值；</span><br><span class="line"></span><br><span class="line">first_bin=1;</span><br><span class="line">exponent_base=2;</span><br><span class="line"></span><br><span class="line">upper_limit=first_bin;    %代表总的格子数；</span><br><span class="line">length_edges=length(edges);</span><br><span class="line">count_exponent=1;</span><br><span class="line">edges_exponent(1)=(edges(upper_limit+1)+edges(1))/2;</span><br><span class="line">N_hist_exponent(1)=sum(N_hist(1:upper_limit))/upper_limit;</span><br><span class="line">while (upper_limit+exponent_base^count_exponent+1)&lt;=length_edges</span><br><span class="line">    upper_limit1=upper_limit+exponent_base^count_exponent;</span><br><span class="line">    count_exponent=count_exponent+1;</span><br><span class="line">    edges_exponent(count_exponent)=(edges(upper_limit1+1)+edges(upper_limit+1))/2;</span><br><span class="line">    N_hist_exponent(count_exponent)=sum(N_hist((upper_limit+1):upper_limit1))/(upper_limit1-upper_limit);</span><br><span class="line">    upper_limit=upper_limit1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">upper_limit1=upper_limit+exponent_base^count_exponent;</span><br><span class="line">count_exponent=count_exponent+1;</span><br><span class="line">edges_exponent(count_exponent)=(2*edges(upper_limit+1)+(upper_limit1-upper_limit)*(edges(3)-edges(2)))/2;</span><br><span class="line">N_hist_exponent(count_exponent)=sum(N_hist((upper_limit+1):end))/(upper_limit1-upper_limit);</span><br><span class="line">upper_limit=upper_limit1;</span><br><span class="line"></span><br><span class="line">edges_exponent=edges_exponent&#x27;;</span><br><span class="line">N_hist_exponent=N_hist_exponent&#x27;;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>其中作为在<span
class="math inline">\(\log\)</span>横坐标下的edges_exponent值的间隔为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log10(edges_exponent(2:end))-log10(edges_exponent(1:(end-1)))</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    0.6021    0.3979    0.3424    0.3203    0.3104    0.3056    0.3033</span><br></pre></td></tr></table></figure>
<p>由于其比值选的也是<span
class="math inline">\(2\)</span>，所以最终的间距逐渐趋近为<span
class="math inline">\(\log(2)=0.30103\)</span>。 <img
src="https://img-blog.csdnimg.cn/87249ef39f674b9e8bbdd091c41d2ad9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVuZ0FkdmVudHVyZQ==,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center%20=300x300"
alt="图 取线性横坐标中值" /></p>
<ul>
<li>注意</li>
</ul>
<p>如果横坐标为连续变量，则图中的前几个点（从左数）会往上翘起来，并且大部分点相对理论值会偏右（或上）。这是因为，此时由于对连续变量进行hist的时候，会取区间的整个数值的平均值，所以当这个区间内的前后有数值上的单调性（如果左高右低），此值会被区间内左侧的值拉高，高于区间中间位置的值的大小。解决的办法是把hist的区间数取大，进而减小区间的大小，减小拉高的高度。但是值得注意的是，这个区间也不能取的太小，太小的话可能会因为涨落的原因，使数据点低垂下去，或者翘起来。所以需要根据数据的具体情况进行调整。
其实这也一定程度上显露了区间位置被选在线性区间中间这个操作的缺点。当我们取横坐标为<span
class="math inline">\(\log\)</span>之后的值的平均值的时候，可以克服这个缺点：</p>
<p><img
src="https://img-blog.csdnimg.cn/5d7c69cc93ff4d8bb024f22bb7663cf5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVuZ0FkdmVudHVyZQ==,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center%20=300x300"
alt="图 取对数横坐标中值" />
另外上面点在横坐标上的分布其实也不均匀。下面对一般情况下的离散变量（连续变量可以通过粗粒化转化为离散变量）进行证明，假设初值<span
class="math inline">\(b_{1}=a_{1}\)</span>，比值<span
class="math inline">\(q&gt;1\)</span>，则前<span
class="math inline">\(n\)</span>项的求和为： <span
class="math display">\[
\begin{equation}
S_{n}=\frac{a_{1}(1-q^{n})}{1-q}
\end{equation}
\]</span></p>
<p>当<span class="math inline">\(n\rightarrow\infty\)</span>，且<span
class="math inline">\(q&gt;1\)</span>时，<span
class="math inline">\(\left\langle k_{n} \right\rangle\)</span>在<span
class="math inline">\(\log\)</span>坐标下的值为： <span
class="math display">\[
\begin{equation}
\begin{aligned}
\left\langle k_{n}
\right\rangle_{log}&amp;=\frac{\log(S_{n-1})+\log(S_{n})}{2}\\
&amp;=\frac{\log(S_{n-1}S_{n})}{2}\\
&amp;=\frac{\log(\frac{a_{1}^{2}(1-q^{n-1})(1-q^{n})}{(1-q)^{2}})}{2}\\
&amp;\approx \frac{\log(\frac{a_{1}^{2}q^{2n}}{q(1-q)^{2}})}{2}\\
&amp;\approx \frac{2n\log(q)+\log(\frac{a_{1}^{2}}{q(1-q)^{2}})}{2}\\
&amp;\approx n\log(q)+\frac{1}{2}\log(\frac{a_{1}^{2}}{q(1-q)^{2}})\\
&amp;\approx n\log(q)\\
\end{aligned}
\end{equation}
\]</span> 比较之前得到的在线性区间下的结果，当<span
class="math inline">\(n\rightarrow\infty\)</span>时，两者一致。
另外当<span class="math inline">\(a_{1}\)</span>较小，<span
class="math inline">\(q\)</span>较大时，点在横坐标上的分布会比较均匀。</p>
<p>代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%计算log-binning，输出线性坐标下的横坐标和纵坐标；</span><br><span class="line">function [edges_exponent,N_hist_exponent]=LogBinning(N_hist,edges,first_bin,exponent_base)</span><br><span class="line">%N_hist为数据，edges为横坐标（其length比N_hist多1），first_bin为横坐标第一个格子大小；</span><br><span class="line">%exponent_base为比值；</span><br><span class="line">%edges_exponent为横坐标，N_hist_exponent为纵坐标值；</span><br><span class="line"></span><br><span class="line">first_bin=1;</span><br><span class="line">exponent_base=2;</span><br><span class="line"></span><br><span class="line">upper_limit=first_bin;    %代表总的格子数；</span><br><span class="line">length_edges=length(edges);</span><br><span class="line">count_exponent=1;</span><br><span class="line">edges_exponent(1)=10^((log10(edges(upper_limit+1))+log10(edges(1)))/2);</span><br><span class="line">N_hist_exponent(1)=sum(N_hist(1:upper_limit))/upper_limit;</span><br><span class="line">while (upper_limit+exponent_base^count_exponent+1)&lt;=length_edges</span><br><span class="line">    upper_limit1=upper_limit+exponent_base^count_exponent;</span><br><span class="line">    count_exponent=count_exponent+1;</span><br><span class="line">    edges_exponent(count_exponent)=10^((log10(edges(upper_limit1+1))+log10(edges(upper_limit+1)))/2);    %注意横坐标需要取对数坐标下的中间值，求完之后为了防止混淆，再退化为线性坐标；</span><br><span class="line">    N_hist_exponent(count_exponent)=sum(N_hist((upper_limit+1):upper_limit1))/(upper_limit1-upper_limit);</span><br><span class="line">    upper_limit=upper_limit1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 注意此时超出范围，需要额外处理；</span><br><span class="line">upper_limit1=upper_limit+exponent_base^count_exponent;</span><br><span class="line">count_exponent=count_exponent+1;</span><br><span class="line">edges_exponent(count_exponent)=10^((log10(edges(upper_limit+1))+log10(edges(upper_limit+1)+(upper_limit1-upper_limit)*(edges(3)-edges(2))))/2);</span><br><span class="line">N_hist_exponent(count_exponent)=sum(N_hist((upper_limit+1):end))/(upper_limit1-upper_limit);</span><br><span class="line">upper_limit=upper_limit1;</span><br><span class="line"></span><br><span class="line">edges_exponent=edges_exponent&#x27;;</span><br><span class="line">N_hist_exponent=N_hist_exponent&#x27;;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>参考文献：barabasi，network science，chapter4.</p>
<p>​</p>
<p>​</p>
<p>​​​​​​</p>
]]></content>
      <categories>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>Log Binning</tag>
      </tags>
  </entry>
  <entry>
    <title>双对数坐标（log-log）下“斜率”“幅值”等概念对应到线性坐标下的实际含义</title>
    <url>/2022/04/03/%E5%8F%8C%E5%AF%B9%E6%95%B0%E5%9D%90%E6%A0%87%EF%BC%88log-log%EF%BC%89%E4%B8%8B%E2%80%9C%E6%96%9C%E7%8E%87%E2%80%9D%E2%80%9C%E5%B9%85%E5%80%BC%E2%80%9D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%AF%B9%E5%BA%94%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cd2da69755fe9f323580e95e4ba342fa1e67091a05c01d1213f80f7982b366f5">86b85d31e3c6e7c1cf3ce1e8abd51d568db46067e139bf2649d8807709ba16a9ef5e56ef4b50b09757952747d1cdc7ee5ea05eb415c284e12bdb4b95a0dc230430b9744aefa53cfbdbe819a0ee71dc00d0d22a356de4750f116f729005d332b064e676bdab96046511c9fcc290827bcc72393c30c36e237c41f5174754b40f0c82f8eb1e76102406394c9191807f3c28c5348b44ab8abeb9310870898351141f564abaf7b2b3e2b5adb7c2e8e72e29c92682ac988709ac536a600d12cdbf7d601432bf5c7943395877f1e7478a2819dadc662a1e5c25c19a6a3fa779d0bd730e58da5cbe513007315c1bb4abba663512c275df9351d11358fa65770f63e191fbf46a96f3233db81360bbd0d90a20a48045625960bc983525110272a69b9fd2d848d25efb0dd2f790c738d166784545cba88420b1fca0fda4721cd7cef6e3dfdf7873e6942c3f3e58f18e43e3552dcbd7e102bad27bc5667236c744f1d9864ca7796539878b40e1ab4378d31c3404af6cf73c2f128a898ae0cf52a66677133e38f85b3fd3347c5cd072eae44678a9de7aee69d92e8a0a7793083192bf9c3ed24fe0dce6a7ad411720a25656242966a6f753345e846cd74e377ad8d535aa407e265fb79febba8a0a68525ad2234e0181bd72923727faebc6b2be96c69b4ca15c861e7c3418155d2d8e2d599a0f5c7d0eb63e96526fbbee39244a4d75a945aced75f20af15193597fa1de60d8756267ebec4ec271b99b853ecabaf12bd4256da3c1c5855666212561e870fb411e4c74203eea6bc403c334efabd9a209509348f08e43823d6dce94b276a00beb905a2fe22703aa8b4bfee68c02088d2a5a0e15d280e835b0ec53f8f3a9e8785eabf45cbefe6fd4df2fb97e4db4182ed70bb8749b0279f7b9ee9c8678a07024dd7ef606a3e5c6d61345c41236fb47ad0cb6937d18a9f7e57a6620ebc1164af52eba5f6a3dd2a8cfbafb8d8943ba3bf945fd720054032463d5d41d5bba59b83550485e0c03ead409543e3742fda627c6d2dbd12232fb16f55c1a339c90fc3b70a437a6016fcc41d0525d1a89afaea95a9acfa886d948d19fa3d817de17211cdbadfd05a7e7241aca24f7beee568231b7c296db8afbfbe27f157961ebce9b0cae71de8097eddf1cbe2edc79940dfe39a3adbdcfa26db475829814db869c2fea0f37290680e561c53e9cb2516672805e0f5b42a1cb9dc1907dc5f4303e023328524ddbe6506f4dd70572df6818e03a9ac52c6420c0b00a2c9d9a482977758f77739fcd7dd6d3b0cb86e0be9baf45a34b4902e2b7ea40b986c57add83f5cc2bcd7c9942e064cb3183ef66ab8741939ae30ea3fe991fba175b2237f62296c0b7cc5c4d50d7b04321b46199db163434c39a77afeea7b26f4004204f5e6b23d57e4e7d9868e97e211dd8a60850d5efcaed308b0b7c8c550c41d477e9f33d0ea8b0afc6530577ccddda9fa46f2ed1a8d75ad8bfd165ebac13d57140f8b82c6058ab38d3af178b6981145dc31f25881e06fd93e0394ad3ec6e5d1ea295d7b423f007836f9f4dd949e2bcf4be6e3b0e1fef54fac59178142bb01cdb0abcddc5358bc6297d549289a328c5844fe9b6dd5aed0684ee09c057e465f264dc57e34b6ec5a41a20436975d08e05b15936f0c7cd0d5912c12860c3b12cda8cd508731d62396e0171f05b202828ed0214757cc60af0c7ac08dbbf37e9bdb30c23795edbdbdc45cff827570a4cfafa7d0a3668c874367ff5abc1ab9ab29dd6a6c1a778cacf68d305783f16f653b1cf10c2ec1af71e91d200fb15b1a8414eb5919cf08bfef2d129a8d764cb6195a5ea94bb3785de0d95d84917acf53bcd1987b196ad5833e8bfb0696067efacb3321e568d5102edb21f6d70ccc017a57cc823decbd1e0be5fd009b415cc1841678b4072c7181e12957246ee90c829689d8d548a3942a0e3c030abfe20cb2faa37ae8caa3934912aabfcf2917f33a1278da7ad2ab3efa7c80fbae344cd1e3e3e6e7deb5069a2cfdcaecaecad000920521a13d342630836f2cb949e5268f351abdc60ffd8c240497ab7a93a491629f73db6520b8b94add35d2747aa565acc4476ff2b8afc01cef5fe5b44db70a8fec3f6f592f53fab4fa957f03818591341806fced232d98359edaf421abaec982aa6819007e2120b908c8712c565185365bdd1ce86b83dc91f774e0af885885a61bf3007da6a2b7b190199e862a850f8f118eccaa09f2a492da0d3b82dfbd7d6cd7d3f38faa8e300f45ada28b0c33c5677562ea5a65486a80e49579c3f4fc684c885fe208f679b29dd0e5c8e329c2eaddb23a47f4f1983c8f57bc24582d5334a9171dbfd0e6ebfa38fc949f4a3c2288a7c2998b2592c8a01d56a75b6a61188dbe5c201432928274d0a5f6dbf0e1835176d59f3aff557300a17eeaf0af6f3009710b96f2fa248423f8771efd3d34a01b87052ccd1008407a8e08cb3c81f2b38cdb59cef04fe047e056bd38295ed67b2a0ff99704eeb72a4611c2c0daa01a4f75ab096d6784d524aebfd5f5bf12462223c74c236ef07299ced4a7167d88c0b26d4978bc8cf89553116006db9f60dd0ce8a477a2798fc0291cb151a41ecc6ac84c76fa34cb9c8f28790c96dc490c28dd9afc5c1ee13ca481609a02a82d5e599f3b3d06721361a3a1080134aa25763ee576e2eb0425a3d8905ef771c0ba47b5bda5b308473aea60aefd39f97f11c841638880ea6f88dc916feba01e318af06665ec6cc573d60b00cbbc8f682dae6e5cf0c709462ecf67fee4ce2a1d3b407213ad5071bbc06eb6fcf15333ef3b294c0eb0c9defc2fe16d536682cee4a1a75fd2529434476b10893ce9573deece19f2a4f25be39e022d25810e143aaa905ea8b5064dd3a8de6a576cef9f403d5039a1288a5d535e163a06c5d25a10fefa2202c5bfeebbf859b2142f9b53c48c0bde9b05dfef30ca9cb56cfa3af6530cfbd16e0fb8b7c9671a89c8267b165800cdf7d4edd382f2fadc709ec83a4c506c54e1a1d6cc011fbf67bfb8df7d1df6f9d0c668b59d108cc9de5af309d89bd1bc4f14cd01d031fbf702845e1d122c723df08c1adcfef25fbabd1e041a013212e74a0f2d0eb56017d1c80b18a440e8e9108123f9df5a8f8c6fe1e2279c6555db3d34afe93fdbce1fbc1fc75e708397ca647fdb97ae778b44c77454ccff5c13c3d6425cb0c16108794da61de923474e9216ff51debbffe2e27bf427e89ba696358c60fca391f129ef9eed24c42057ede456a6fff6515a293ddec1643c05d4026e6c57ed0dcff78b070eb4b3744fd99f2294348549eb976437776d41241d8c5d9d56a02160ed4c89d2226ebc24f842111e09a734241733d2633dfb414dc7d0daef64084efa49cde500d1858cc8ded0c1e607f305fe668acbc14039d2fdff0062719e1340e15f6d3ae88dafa8084517eae7de3e955596c6674f2a3fa40547b207dad6272e839ae7b32887499adc39048e02ad6e520eefbada06acfefd86e3716a00480fab1df90117fd1c783b122d571335635faaa41f3b4f66eaaec6317e65f6d7444c3accffa22f464450fc137cc987103b1df595ff01a37ebae12b6c50ff95ce1938eb2e571830492c2fc815dbfbc5ef5f7caf25847674f442114705a9e8c089e2f57fb57412d6e6fc5db3a1902d43612935c85c76e943d478cfd2807748bba78792eb655e08502228e8059c2ae267abae4379e04b5a5e3acfffcd831769edd75730c8c784b808c2bc841bae19e3c4c0797d49c584a70a5fe1e461a9ecd51c3e1e4901134db34294f76c008dfa451310caee5dbeb4a88099e3956b0e9aa932866c0b79ab3e8d2f9333f40333c1ce9b47b2538d259b096d2e2ca1375be6420613e7490d3e2df3beccec205e8f08b57a4e2467d5e0749a7f4b82fed4775092f6e809d0f71072a1e37310f06021f11bf706f8e1edea5b30c853f1eda5d377af24dd6586beebb3ae9ca4f700bddc9754a400e76069d9b56ac5015bed87337e18246d7e01d34e9fe6760a7249fcfc495ffbbcda07e7dd97a1e7dc32015d08b45f460dadcc08b1647ee56c3434756beed804716902a3b2d3e1fec108285e5552478769924ae400ed176c009b4cee383ef7d3a39afcce7cf037ac5a678cea6b0a583862abb5d1dd64b6254f524d550276477b6b770f5277931b7bb4f521584f3eef83805cd5cffd8cb044f957b2449f1bcaaab3c820f8d5050c889470076a0a7d011454caf4348592f1d38a58ab42ef0d012041b57aa6d094bf43e8c77b053c6b16239440fd3cd9c5e2e7b0469efec546f526c790ae98b4bd599c0996d9ab49bd5400b02e0e0002200a236683fd037d9700791ecb5ccd9b2ac064d9183ff3007f5833516943e2939b51e1451c5858f8f9bf558facc3e1ebbb630e53a7b321715fe50f81d6b6331c64e9bcdb3f062cdea1b9e74fe33c0ce6f6aafbbb4d8e8668ed1bfa57b7d5ee52ed88f508f6cc3812ca85050167fb4de1f8541206c992e9e579de4928d854b3b0064fb3cf7ec079ee6e3e1b31950083b69ab8874897ea28834b59a069aa480a59a9f75b5bf90208e1cc3e84654c8792612f4616cd7dfcc6ccdba50a4f634b167079a5c8499964633dc13704b392d7eb7281a9177af35cc5d53014349907cd56eb7e7aa2ab86fa3a75451fb5e6832ba7eaa551663375759fc122dc649daab1b099926f412272da57af2e2384c39294bd506d0b25c4ee6c2289ebc1018726588631d19103be56c279173e5131ed41f8f78d823449a677401d287c6e019739a1db7564eedb4dd5daf82688b47d3cbc2d3151073ff0c7292a7e4784512c54fcd814a511d3aa46e37da1a73834736c8732ac80ab8d6fbb4b45380f68915ceadd5216f7b179f7c2a81dfe29cf91eec078fa1b78decd1919e82415a3eb0c2df9f7ba3f8e90fb2111c1063eb03888ddb9c8342a95cc175a61293ebe2a2b1b962486020671f2401fa3681414e77f38814704c36907c3dc4c7bbcaee4f9edff5d1b5b75864cb54100b831cb7bc716e2d8600b7279b891183a78cbaa82a2a4ae0740f21e082324a90b2e8ffdfb8c6dae9cfb879a446f671e376a2afe06b78a94eb30927d6ae7d1be9cac937f18fe3110fa821780719138be1fe1e61e1f8b0c8d4d55d435246f90d73dd01eccc5167ddedac4acfd56749ebd5240d1101594ab9c82554975c8c7b43e6c0ff26e5172047a03c9c3d7571109063e7dcdd33c26556d24369c8fb77216f55ba5be9b6425658733192c97feb26bfaf6ccb3fd976674faa9c0b04fdef4610bf0fb9984bbb193af72f577a97389f5a3790f046fe0d83dd9bfac3a86b5f856974875fbda5c6a25c2c066ad39f67a5adb3915f7dd29aaf7b0ac87b7cea381ebfaab2d5723e3109223f0bf647bff2f78c57e37389d8883bf9821f0a28849505392f5f7555297da243121264cf77f0e6f3afc51a56735db04a61b025a74f34f1db902bdcb543525dd3e772a628ef5d5bd857c176c41d80e4735b6771699a2767c26e913bc20d786c1c8555d8aedbb8d25592f5c3196393ac3ba10c54142cb4da1852253cd1bba7a7d8c84e74b677f441fe2d7c7a6108aef5bc54888e236f75fb17bb1193c252ff878b210fc865adf6f5b2bc5cea9fbc5fe1b8f08001924e8a1aaf8df2d65f00709c36d8bbd8fe2713694d0cbe4dd3f02163aea6d68bfbe75d0d3229ee95ae2e520a45631bfb0eced993b819e059183663345a4af0f2c0f132a8d06300fea7899b5e52dfc38cbc1581e8032a8c638b389fbef938fa4938dfe6aec80197887bf82cc9fba5894654e20533071a3d38c75ebddaaf521c030a55e2504ca9c7d2e2472a89b53646b183f0a3c002172984e7fca346ef34b11c0fc42bc71a5d2da590ddebc805d9c35f5f4d12c79a1218ce273732643b367cb68d87fa610d97333b133aff1bb6c2a7fc6e598079320095cde21f338da6868cd24b8f26d75e7bcd9de04d2554cd72d4f36f6fc941f0d063441fcbfac76a2b96db561d5146316b37a7b9b2b419f22d4efee1951d1f81863930109136ba4a61318ba49b23881b081477c695275cc0b85393ead9f87768c23b2998dd5ffd178e56958c2081808b94b95474c5e7d208fcf1b87e5e1c73395797d0003a294a36250bc61615bcf316c1b01e966d7d2eccf35e1d85bfb7db631fe03110ad5bb809c739eaf0aaa1669723864e4fcd755a00e8f35e39636b8fb3a75e2dd0a6f74ce21255681a8184e82529913a11a1eeecdd18a5cc497dfc36f96868e9112002493dea4610e5e6f1445a531a55c3c41c5f6d22cf61bd2fa1d9e67c0e6ea52b21598d78fcfb1cbe55b246fdc1f33f41e51fd955873fa9321cc945dd7beb896a1323f92b0cc122d9981311e353d1ae144831b3c8d955fe63b273df7013ebb95dfbd3b667993499eb1b919895b9d17f62efdf2171e723ff851cecb43b1cb81d44ad4f4839c26d906a88cb88716a6bd84006937f9020352bd1542c86f30575fa668018b5494600ab98cb96fa2e67d1d1442f96b2876309a438ebb049155e71ebc7e3e3f3abbf2594f178837c64f77ab8048321208af07ac5bcf7860257b28c6edfca5f5da1e420ac4e1bda4651846d3772367b8308481bbc97e4a298f0748a6d10e7162fc6479979c894522091302e97065184324f2e1f0db6ca593357d20fd6167f3c99438c81d7ddb290fb7aefc82afca21690492df3b282ab3a99e2b9ba9dc9c1e62b26dfb49f11a3dc6b6b73f711105978e87ac41600a4a70e2e8bfed08ade66d1c3c7f7e10d6cb7ccf1dddc95119b84fc09cb5ca3f51c1568ebfb2101d5833387ccf09bcc97825564209e67b12365990c6d4891c3319be4f82ecd408d008bceec256391df04fc257057a92573a734f27ff2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>log-log</tag>
      </tags>
  </entry>
  <entry>
    <title>数学算术中无穷小量的不完备性</title>
    <url>/2022/04/11/%E6%95%B0%E5%AD%A6%E7%AE%97%E6%9C%AF%E4%B8%AD%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%A4%87%E6%80%A7/</url>
    <content><![CDATA[<p>假设我们有一组微分之后的结果： <span class="math display">\[
a+h \tag{1}
\]</span><br />
其中<span class="math inline">\(a\)</span>是实数，<span
class="math inline">\(h\)</span>为无穷小量，则一般情况下我们可以忽略掉h使其变为：<span id="more"></span>
<span class="math display">\[
a+h\rightarrow a\tag{2}
\]</span></p>
<ol type="1">
<li>当我们拿着上述结果<span
class="math inline">\((2)\)</span>交给另一个人去计算： <span
class="math display">\[
\frac{a-a}{h}\tag{3}
\]</span><br />
时，<span class="math inline">\(h\)</span>为无穷小量，第一个<span
class="math inline">\(a\)</span>为前式得到的<span
class="math inline">\(a\)</span>，则上式可以简化为： <span
class="math display">\[
\frac{a-a}{h}=\frac{0}{h}\rightarrow0\tag{4}
\]</span></li>
<li>当我们拿着化简之前的结果<span
class="math inline">\((1)\)</span>式交给别人去计算时，<span
class="math inline">\((3)\)</span>式可简化为： <span
class="math display">\[
\frac{a+h-a}{h}=\frac{h}{h}\rightarrow1\tag{5}
\]</span> 显然<span class="math inline">\((3)\)</span>和<span
class="math inline">\((5)\)</span>式进行着相同的计算，在不同的取值近似下得出了完全不相同的结果，这是无穷小量带来的算术矛盾。需要验证在现实中我们是否经常遇到这种矛盾，这如同一个隐患一样藏在某处。</li>
</ol>
<p>​</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>长方形面积公式的由来</title>
    <url>/2022/04/13/%E9%95%BF%E6%96%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    <content><![CDATA[<p>先说大家都知道的：假定长方形的边长分别为实数<span
class="math inline">\(a\)</span>，<span
class="math inline">\(b\)</span>，则面积可以表示为：</p>
<p><span class="math display">\[
S=ab.\tag{1}
\]</span></p>
<p>但是长方形的面积为何如此定义呢？这是人为定义？还是纯天然的？哪来的？
首先从历史角度来说，这是人通过实践的经验得来的。我们可以考虑这样的场景：把很多物体按照行和列排列，则最终物体的总数就是行数乘上列数，如下图的南瓜：
<img
src="https://img-blog.csdnimg.cn/e8e74a31052b4f19a11acb1ac1938b17.png?x_16#pic_center%20=300x300"
alt="南瓜" /></p>
<p>对于离散的数量来说，这种定义确实是足以示性这种排列的规律。但问题是：这种离散的计数是否能够适用于连续的实数中去呢？当然我们可以继续把连续的图形划分成小格子，然后数格子的数量，但是前提是格子的边长必须是单位长度，而总的边长能够被这个单位长度整除，那么不整除的情况呢？其实这个思考过程就是一个把面积的定义从有理数域推向实数域的过程。这就不得不涉及到现代数学的很多概念。
下面我们从现代数学的角度再来看这个问题。
首先我们来梳理一下在我们传统的印象中，我们所需要的面积应该满足哪些约束条件，或者说它应该具备哪些我们想要的基本特点：
1.
全等的图形面积应该都相等（平面平移对称性），而长和宽对应相等的长方形是全等的，所以面积是两个边长的函数<span
class="math inline">\(f(a,b)\)</span>； 2.
由于两条边具有交换对称性，也就有： <span class="math display">\[
f(a,b)=f(b,a)\tag{2}
\]</span> 3.
规定面积是恒正的函数，不存在面积为负的情况，边长不为0时面积不为0； 4.
面积应该具有可加性，两个图形拼起来的面积是两者之和。假设两个长方形的某一边相等（此处为<span
class="math inline">\(b\)</span>），则两者可以重新拼接成一个长方形，即：</p>
<p><span class="math display">\[
f(a_{1}+a_{2},b)=f(a_{1},b)+f(a_{2},b)\tag{3}
\]</span> 由此可以看出<span class="math inline">\(f\)</span>关于<span
class="math inline">\(a\)</span>单调递增；</p>
<ol start="5" type="1">
<li>假设存在正整数<span class="math inline">\(q_{1}\)</span>，<span
class="math inline">\(q_{2}\)</span>，则由<span
class="math inline">\((3)\)</span>式有： <span class="math display">\[
\begin{aligned}
f(a,b)&amp;=q_{1}f(\frac{1}{q_{1}}a,b)\\\tag{4}
\Rightarrow\frac{1}{q_{1}}f(a,b)&amp;=f(\frac{1}{q_{1}} a,b)
\end{aligned}
\]</span> 当有<span
class="math inline">\(q_{2}\)</span>个上式相加时，则上式变为： <span
class="math display">\[
\frac{q_{2}}{q_{1}}f(a,b)=f(\frac{q_{2}}{q_{1}} a,b)\tag{5}
\]</span> 此时令<span
class="math inline">\(q=\frac{q_{2}}{q_{1}}\)</span>，则<span
class="math inline">\((3)\)</span>中的公式可以写为有理数的形式： <span
class="math display">\[
qf(a,b)=f(qa,b)\tag{6}
\]</span></li>
<li><span class="math inline">\(f(a,b)\)</span>在<span
class="math inline">\(a\)</span>趋向于某个实数<span
class="math inline">\(a_{1}\)</span>时极限为<span
class="math inline">\(f(a_{1},b)\)</span>，即<span
class="math inline">\(f(a,b)\)</span>可以任意接近于<span
class="math inline">\(f(a_{1},b)\)</span>，所以<span
class="math inline">\(f\)</span>关于<span
class="math inline">\(a\)</span>连续，于是可以把<span
class="math inline">\((6)\)</span>式中的<span
class="math inline">\(q\)</span>推广到任意实数<span
class="math inline">\(u\)</span>： <span class="math display">\[
uf(a,b) = f(ua,b)\tag{7}
\]</span></li>
<li>将上式<span class="math inline">\(u=a\)</span>，<span
class="math inline">\(a=1\)</span>，得到 <span class="math display">\[
f(a,b)=af(1,b)\tag{8}
\]</span> 同理，根据<span class="math inline">\((2)\)</span>式： <span
class="math display">\[
f(a,b) = bf(a,1)\tag{9}
\]</span></li>
<li>因此： <span class="math display">\[
f(a,b)=abf(1,1)\tag{10}
\]</span> 由上可以看出面积必须是<span
class="math inline">\(ab\)</span>的常数倍，为了使用方便可以规定<span
class="math inline">\(f(1,1)=1\)</span>，当然也可以规定为其他数字。因此得到最终长方形的面积公式：
<span class="math display">\[
S=f(a,b)=ab.\tag{11}
\]</span></li>
</ol>
<p>由上述推导可以知道，传统意义上的长方形的面积公式可以根据几个基本原理（约束）推论得到。
值得注意的是，我们也可以用同样的方法得到体积公式，此时需要注意体积公式和面积公式的常数项要一致才行，所以从面积推广到<span
class="math inline">\(n\)</span>维体积的定义需要前后一致，否则会出现矛盾。
在上述推导中主要运用的是面积的测度性质。此处并未讨论上述坐标得到的长度是在什么基向量下表示的（只是用到了平面的平移对称性），也就还没有涉及到空间的基向量的变换。如果推广到欧式空间，则还需要内积空间的性质。面积恒正可加是测度性质，面积在正交变换下保持不变是欧式空间的内积空间性质。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
